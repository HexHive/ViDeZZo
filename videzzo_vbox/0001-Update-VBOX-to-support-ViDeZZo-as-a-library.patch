diff --git a/Config.kmk b/Config.kmk
index 2bc51041..0dca89dd 100644
--- a/Config.kmk
+++ b/Config.kmk
@@ -821,6 +821,8 @@ VBOX_WITH_VBOXSDL =
 VBOX_WITH_VBOXSVC_SESSION_0 = 1
 # The headless frontend.
 VBOX_WITH_HEADLESS = 1
+# The videzzo frontend.
+VBOX_WITH_VIDEZZO = 1
 # Enable the build of VRDP server.
 VBOX_WITH_VRDP = 1
 # Build the VRDP authentication modules.
@@ -1253,6 +1255,7 @@ ifdef VBOX_QUICK
  VBOX_WITH_TESTCASES =
  VBOX_WITH_VBOXSDL =
  VBOX_WITH_HEADLESS =
+ VBOX_WITH_VIDEZZO = 
  VBOX_WITH_VRDP =
  VBOX_WITH_VRDP_RDESKTOP =
  VBOX_WITH_DOCS =
@@ -1260,6 +1263,32 @@ ifdef VBOX_QUICK
  VBOX_WITH_32_ON_64_MAIN_API =
 endif # VBOX_QUICK
 
+# VBOX_FUZZ can be used to build the fuzzer only
+ifdef VBOX_FUZZ
+ # undefine variables by assigning blank.
+ VBOX_WITH_ADDITIONS=
+ VBOX_WITH_VALIDATIONKIT=
+ VBOX_WITH_TESTCASES=
+ VBOX_WITH_VBOXSDL=
+ VBOX_WITH_VRDP=
+ VBOX_WITH_VRDP_RDESKTOP=
+ VBOX_WITH_DOCS=
+ VBOX_WITH_WEBSERVICES=
+ VBOX_WITH_32_ON_64_MAIN_API=
+ VBOX_WITH_QTGUI=
+ VBOX_WITH_NLS =
+ VBOX_WITH_MAIN_NLS =
+ VBOX_WITH_PUEL_NLS =
+ VBOX_WITH_VBOXMANAGE_NLS =
+ VBOX_WITH_DOCS_QHELP =
+ VBOX_WITH_DOCS_QHELP_PACKING =
+ VBOX_WITH_WEBSERVICES =
+ VBOX_WITH_FE_BALLOONCTRL =
+ VBOX_WITH_FE_AUTOSTART =
+ VBOX_WITH_FE_BUGREPORT =
+ VBOX_WITH_VBOXIMGMOUNT =
+endif # VBOX_FUZZ
+
 # Only AMD64 is supported for the main product, so disable most of the other bits.
 ifn1of ($(KBUILD_TARGET_ARCH), $(VBOX_SUPPORTED_HOST_ARCHS))
  VBOX_WITH_MAIN =
@@ -1307,6 +1336,7 @@ ifeq ($(KBUILD_TARGET),haiku)
  VBOX_WITH_VBOXDRV =
  VBOX_WITH_VRDP =
  VBOX_WITH_HEADLESS =
+ VBOX_WITH_VIDEZZO = 
  VBOX_WITH_VBOXSDL =
  VBOX_WITH_QTGUI =
  # VBOX_WITH_MAIN=
@@ -1318,7 +1348,6 @@ ifeq ($(KBUILD_TARGET),haiku)
  VBOX_WITH_HARDENING =
 endif
 
-
 ifeq ($(KBUILD_TARGET),os2)
  VBOX_WITH_WEBSERVICES =
  VBOX_WITH_INSTALLER =
@@ -1344,6 +1373,7 @@ ifn1of ($(KBUILD_TARGET_ARCH), x86 amd64 arm64)
  VBOX_WITH_EHCI =
  VBOX_WITH_HARDENING =
  VBOX_WITH_HEADLESS =
+ VBOX_WITH_HEADLESS = 
  VBOX_WITH_HGCM =
  VBOX_WITH_HGSMI =
  VBOX_WITH_INIP =
@@ -1595,6 +1625,7 @@ ifndef VBOX_WITH_MAIN
  VBOX_WITH_QTGUI =
  VBOX_WITH_DEBUGGER_GUI =
  VBOX_WITH_HEADLESS =
+ VBOX_WITH_VIDEZZO =
  ifdef VBOX_ONLY_DOCS
   $(error Oh, does VBOX_ONLY_DOCS actually end up here. sweet.)
  endif
@@ -5441,7 +5472,11 @@ ifeq ($(VBOX_LDR_FMT),pe)
 endif # pe
 
 ifeq ($(VBOX_LDR_FMT),elf)
- TEMPLATE_VBoxR0_TOOL               = $(VBOX_GCC_TOOL)
+ if1of ($(VBOX_GCC_TOOL), CLANG)
+  TEMPLATE_VBoxR0_TOOL              = GXX64
+ else
+  TEMPLATE_VBoxR0_TOOL              = $(VBOX_GCC_TOOL)
+ endif
  TEMPLATE_VBoxR0_CFLAGS             = -fno-pie -nostdinc -g $(VBOX_GCC_pipe) $(VBOX_GCC_WERR) $(VBOX_GCC_PEDANTIC_C) \
  	$(VBOX_GCC_Wno-variadic-macros) $(VBOX_GCC_R0_OPT) $(VBOX_GCC_R0_FP) -fno-strict-aliasing -fno-exceptions \
  	$(VBOX_GCC_fno-stack-protector) -fno-common -ffreestanding $(VBOX_GCC_fvisibility-hidden) -std=gnu99 $(VBOX_GCC_IPRT_FMT_CHECK)
diff --git a/src/VBox/Devices/Graphics/DevVGA-SVGA3d-glLdr.cpp b/src/VBox/Devices/Graphics/DevVGA-SVGA3d-glLdr.cpp
index 3a0b56e3..1e120ff4 100644
--- a/src/VBox/Devices/Graphics/DevVGA-SVGA3d-glLdr.cpp
+++ b/src/VBox/Devices/Graphics/DevVGA-SVGA3d-glLdr.cpp
@@ -307,105 +307,305 @@ int glLdrInit(PPDMDEVINS pDevIns)
     GLGETPROC_(wglMakeCurrent, "");
     GLGETPROC_(wglShareLists, "");
 #elif defined(RT_OS_LINUX)
-    X11GETPROC_(XConfigureWindow);
-    X11GETPROC_(XCloseDisplay);
-    X11GETPROC_(XCreateColormap);
-    X11GETPROC_(XCreatePixmap);
-    X11GETPROC_(XCreateWindow);
-    X11GETPROC_(XDefaultRootWindow);
-    X11GETPROC_(XDestroyWindow);
-    X11GETPROC_(XFree);
-    X11GETPROC_(XFreePixmap);
-    X11GETPROC_(XInitThreads);
-    X11GETPROC_(XNextEvent);
-    X11GETPROC_(XOpenDisplay);
-    X11GETPROC_(XPending);
-    X11GETPROC_(XSetErrorHandler);
-    X11GETPROC_(XSync);
-    X11GETPROC_(XScreenNumberOfScreen);
-    X11GETPROC_(XMapWindow);
-    X11GETPROC_(XGetWindowAttributes);
-    GLGETPROC_(glXGetFBConfigAttrib, "");
-    GLGETPROC_(glXGetVisualFromFBConfig, "");
-    GLGETPROC_(glXQueryVersion, "");
-    GLGETPROC_(glXChooseFBConfig, "");
-    GLGETPROC_(glXChooseVisual, "");
-    GLGETPROC_(glXCreateContext, "");
-    GLGETPROC_(glXCreatePixmap, "");
-    GLGETPROC_(glXMakeCurrent, "");
-    GLGETPROC_(glXDestroyContext, "");
-    GLGETPROC_(glXDestroyPixmap, "");
+    // X11GETPROC_(XConfigureWindow);
+    pfn_XConfigureWindow = (int (*)(Display *display, Window w, unsigned value_mask, XWindowChanges *changes)) MyX11GetProcAddress("XConfigureWindow");
+    if (!pfn_XConfigureWindow) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing libX11 symbol");}
+    // X11GETPROC_(XCloseDisplay);
+    pfn_XCloseDisplay = (int (*)(Display *display)) MyX11GetProcAddress("XCloseDisplay");
+    if (!pfn_XCloseDisplay) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing libX11 symbol");}
+    // X11GETPROC_(XCreateColormap);
+    pfn_XCreateColormap = (Colormap (*)(Display *display, Window w, Visual *visual, int alloc)) MyX11GetProcAddress("XCreateColormap");
+    if (!pfn_XCreateColormap) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing libX11 symbol");}
+    // X11GETPROC_(XCreatePixmap);
+    pfn_XCreatePixmap = (Pixmap (*)(Display *display, Drawable d, unsigned int width, unsigned int height, unsigned int depth)) MyX11GetProcAddress("XCreatePixmap");
+    if (!pfn_XCreatePixmap) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing libX11 symbol");}
+    // X11GETPROC_(XCreateWindow);
+    pfn_XCreateWindow = (Window (*)(Display *display, Window parent, int x, int y, unsigned int width, unsigned int height,
+        unsigned int border_width, int depth, unsigned int window_class, Visual *visual, unsigned long valuemask, XSetWindowAttributes *attributes)) MyX11GetProcAddress("XCreateWindow");
+    if (!pfn_XCreateWindow) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing libX11 symbol");}
+    // X11GETPROC_(XDefaultRootWindow);
+    pfn_XDefaultRootWindow = (Window (*)(Display *display)) MyX11GetProcAddress("XDefaultRootWindow");
+    if (!pfn_XDefaultRootWindow) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing libX11 symbol");}
+    // X11GETPROC_(XDestroyWindow);
+    pfn_XDestroyWindow = (int (*)(Display *display, Window w)) MyX11GetProcAddress("XDestroyWindow");
+    if (!pfn_XDestroyWindow) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing libX11 symbol");}
+    // X11GETPROC_(XFree);
+    pfn_XFree = (int (*)(void *data)) MyX11GetProcAddress("XFree");
+    if (!pfn_XFree) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing libX11 symbol");}
+    // X11GETPROC_(XFreePixmap);
+    pfn_XFreePixmap = (int (*)(Display *display, Pixmap pixmap)) MyX11GetProcAddress("XFreePixmap");
+    if (!pfn_XFreePixmap) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing libX11 symbol");}
+    // X11GETPROC_(XInitThreads);
+    pfn_XInitThreads = (Status (*)(void)) MyX11GetProcAddress("XInitThreads");
+    if (!pfn_XInitThreads) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing libX11 symbol");}
+    // X11GETPROC_(XNextEvent);
+    pfn_XNextEvent = (int (*)(Display *display, XEvent *event_return)) MyX11GetProcAddress("XNextEvent");
+    if (!pfn_XNextEvent) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing libX11 symbol");}
+    // X11GETPROC_(XOpenDisplay);
+    pfn_XOpenDisplay = (Display *(*)(char *display_name)) MyX11GetProcAddress("XOpenDisplay");
+    if (!pfn_XOpenDisplay) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing libX11 symbol");}
+    // X11GETPROC_(XPending);
+    pfn_XPending = (int (*)(Display *display)) MyX11GetProcAddress("XPending");
+    if (!pfn_XPending) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing libX11 symbol");}
+    // X11GETPROC_(XSetErrorHandler);
+    pfn_XSetErrorHandler = (int (* (*)(int (*handler)(Display *, XErrorEvent *)))(Display *, XErrorEvent *)) MyX11GetProcAddress("XSetErrorHandler");
+    if (!pfn_XSetErrorHandler) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing libX11 symbol");}
+    // X11GETPROC_(XSync);
+    pfn_XSync = (int (*)(Display *display, Bool discard)) MyX11GetProcAddress("XSync");
+    if (!pfn_XSync) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing libX11 symbol");}
+    // X11GETPROC_(XScreenNumberOfScreen);
+    pfn_XScreenNumberOfScreen = (int (*)(Screen *screen)) MyX11GetProcAddress("XScreenNumberOfScreen");
+    if (!pfn_XScreenNumberOfScreen) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing libX11 symbol");}
+    // X11GETPROC_(XMapWindow);
+    pfn_XMapWindow = (int (*)(Display *display, Window w)) MyX11GetProcAddress("XMapWindow");
+    if (!pfn_XMapWindow) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing libX11 symbol");}
+    // X11GETPROC_(XGetWindowAttributes);
+    pfn_XGetWindowAttributes = (Status (*)(Display *display, Window w, XWindowAttributes *window_attributes_return)) MyX11GetProcAddress("XGetWindowAttributes");
+    if (!pfn_XGetWindowAttributes) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing libX11 symbol");}
+    // GLGETPROC_(glXGetFBConfigAttrib, "");
+    pfn_glXGetFBConfigAttrib = (int (*)(Display * dpy, GLXFBConfig config, int attribute, int * value)) OGLGETPROCADDRESS("glXGetFBConfigAttrib");
+    if (!pfn_glXGetFBConfigAttrib) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glXGetVisualFromFBConfig, "");
+    pfn_glXGetVisualFromFBConfig = (XVisualInfo * (*)(Display * dpy, GLXFBConfig config)) OGLGETPROCADDRESS("glXGetVisualFromFBConfig");
+    if (!pfn_glXGetVisualFromFBConfig) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glXQueryVersion, "");
+    pfn_glXQueryVersion = (Bool (*)(Display * dpy,  int * major,  int * minor)) OGLGETPROCADDRESS("glXQueryVersion");
+    if (!pfn_glXQueryVersion) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glXChooseFBConfig, "");
+    pfn_glXChooseFBConfig = (GLXFBConfig * (*)(Display * dpy, int screen, const int * attrib_list, int * nelements)) OGLGETPROCADDRESS("glXChooseFBConfig");
+    if (!pfn_glXChooseFBConfig) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glXChooseVisual, "");
+    pfn_glXChooseVisual = (XVisualInfo* (*)(Display * dpy,  int screen,  int * attribList)) OGLGETPROCADDRESS("glXChooseVisual");
+    if (!pfn_glXChooseVisual) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glXCreateContext, "");
+    pfn_glXCreateContext = (GLXContext (*)(Display * dpy,  XVisualInfo * vis,  GLXContext shareList,  Bool direct)) OGLGETPROCADDRESS("glXCreateContext");
+    if (!pfn_glXCreateContext) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glXCreateContext, "");
+    pfn_glXCreateContext = (GLXContext (*)(Display * dpy,  XVisualInfo * vis,  GLXContext shareList,  Bool direct)) OGLGETPROCADDRESS("glXCreateContext");
+    if (!pfn_glXCreateContext) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glXCreatePixmap, "");
+    pfn_glXCreatePixmap = (GLXPixmap (*)(Display * dpy, GLXFBConfig config, Pixmap pixmap, const int * attrib_list)) OGLGETPROCADDRESS("glXCreatePixmap");
+    if (!pfn_glXCreatePixmap) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glXMakeCurrent, "");
+    pfn_glXMakeCurrent = (Bool (*)(Display * dpy,  GLXDrawable drawable,  GLXContext ctx)) OGLGETPROCADDRESS("glXMakeCurrent");
+    if (!pfn_glXMakeCurrent) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glXDestroyContext, "");
+    pfn_glXDestroyContext = (void (*)(Display * dpy,  GLXContext ctx)) OGLGETPROCADDRESS("glXDestroyContext");
+    if (!pfn_glXDestroyContext) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glXDestroyPixmap, "");
+    pfn_glXDestroyPixmap = (void (*)(Display * dpy, GLXPixmap Pixmap)) OGLGETPROCADDRESS("glXDestroyPixmap");
+    if (!pfn_glXDestroyPixmap) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
 #endif
-    GLGETPROC_(glAlphaFunc, "");
-    GLGETPROC_(glBegin, "");
-    GLGETPROC_(glBindTexture, "");
-    GLGETPROC_(glBlendFunc, "");
-    GLGETPROC_(glClear, "");
-    GLGETPROC_(glClearColor, "");
-    GLGETPROC_(glClearDepth, "");
-    GLGETPROC_(glClearStencil, "");
-    GLGETPROC_(glClipPlane, "");
-    GLGETPROC_(glColorMask, "");
-    GLGETPROC_(glColorPointer, "");
-    GLGETPROC_(glCullFace, "");
-    GLGETPROC_(glDeleteTextures, "");
-    GLGETPROC_(glDepthFunc, "");
-    GLGETPROC_(glDepthMask, "");
-    GLGETPROC_(glDepthRange, "");
-    GLGETPROC_(glDisable, "");
-    GLGETPROC_(glDisableClientState, "");
-    GLGETPROC_(glDrawArrays, "");
-    GLGETPROC_(glDrawElements, "");
-    GLGETPROC_(glEnable, "");
-    GLGETPROC_(glEnableClientState, "");
-    GLGETPROC_(glEnd, "");
-    GLGETPROC_(glFinish, "");
-    GLGETPROC_(glFlush, "");
-    GLGETPROC_(glFogf, "");
-    GLGETPROC_(glFogfv, "");
-    GLGETPROC_(glFogi, "");
-    GLGETPROC_(glFrontFace, "");
-    GLGETPROC_(glGenTextures, "");
-    GLGETPROC_(glGetBooleanv, "");
-    GLGETPROC_(glGetError, "");
-    GLGETPROC_(glGetFloatv, "");
-    GLGETPROC_(glGetIntegerv, "");
-    GLGETPROC_(glGetString, "");
-    GLGETPROC_(glGetTexImage, "");
-    GLGETPROC_(glLightModelfv, "");
-    GLGETPROC_(glLightf, "");
-    GLGETPROC_(glLightfv, "");
-    GLGETPROC_(glLineWidth, "");
-    GLGETPROC_(glLoadIdentity, "");
-    GLGETPROC_(glLoadMatrixf, "");
-    GLGETPROC_(glMaterialfv, "");
-    GLGETPROC_(glMatrixMode, "");
-    GLGETPROC_(glMultMatrixf, "");
-    GLGETPROC_(glNormalPointer, "");
-    GLGETPROC_(glOrtho, "");
-    GLGETPROC_(glPixelStorei, "");
-    GLGETPROC_(glPointSize, "");
-    GLGETPROC_(glPolygonMode, "");
-    GLGETPROC_(glPolygonOffset, "");
-    GLGETPROC_(glPopAttrib, "");
-    GLGETPROC_(glPopMatrix, "");
-    GLGETPROC_(glPushAttrib, "");
-    GLGETPROC_(glPushMatrix, "");
-    GLGETPROC_(glScissor, "");
-    GLGETPROC_(glShadeModel, "");
-    GLGETPROC_(glStencilFunc, "");
-    GLGETPROC_(glStencilMask, "");
-    GLGETPROC_(glStencilOp, "");
-    GLGETPROC_(glTexCoord2f, "");
-    GLGETPROC_(glTexCoordPointer, "");
-    GLGETPROC_(glTexImage2D, "");
-    GLGETPROC_(glTexParameterf, "");
-    GLGETPROC_(glTexParameterfv, "");
-    GLGETPROC_(glTexParameteri, "");
-    GLGETPROC_(glTexSubImage2D, "");
-    GLGETPROC_(glVertex2i, "");
-    GLGETPROC_(glVertexPointer, "");
-    GLGETPROC_(glViewport, "");
+    // GLGETPROC_(glAlphaFunc, "");
+    pfn_glAlphaFunc = (void (GLAPIENTRYP)(GLenum func, GLclampf ref)) OGLGETPROCADDRESS("glAlphaFunc");
+    if (!pfn_glAlphaFunc) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glBegin, "");
+    pfn_glBegin = (void (GLAPIENTRYP)(GLenum mode)) OGLGETPROCADDRESS("glBegin");
+    if (!pfn_glBegin) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glBindTexture, "");
+    pfn_glBindTexture = (void (GLAPIENTRYP)(GLenum target, GLuint texture)) OGLGETPROCADDRESS("glBindTexture");
+    if (!pfn_glBindTexture) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glBlendFunc, "");
+    pfn_glBlendFunc = (void (GLAPIENTRYP)(GLenum sfactor, GLenum dfactor)) OGLGETPROCADDRESS("glBlendFunc");
+    if (!pfn_glBlendFunc) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glClear, "");
+    pfn_glClear = (void (GLAPIENTRYP)(GLbitfield mask)) OGLGETPROCADDRESS("glClear");
+    if (!pfn_glClear) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glClearColor, "");
+    pfn_glClearColor = (void (GLAPIENTRYP)(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)) OGLGETPROCADDRESS("glClearColor");
+    if (!pfn_glClearColor) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glClearDepth, "");
+    pfn_glClearDepth = (void (GLAPIENTRYP)(GLclampd depth)) OGLGETPROCADDRESS("glClearDepth");
+    if (!pfn_glClearDepth) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glClearStencil, "");
+    pfn_glClearStencil = (void (GLAPIENTRYP)(GLint s)) OGLGETPROCADDRESS("glClearStencil");
+    if (!pfn_glClearStencil) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glClipPlane, "");
+    pfn_glClipPlane = (void (GLAPIENTRYP)(GLenum plane, const GLdouble *equation)) OGLGETPROCADDRESS("glClipPlane");
+    if (!pfn_glClipPlane) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glColorMask, "");
+    pfn_glColorMask = (void (GLAPIENTRYP)(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)) OGLGETPROCADDRESS("glColorMask");
+    if (!pfn_glColorMask) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glColorPointer, "");
+    pfn_glColorPointer = (void (GLAPIENTRYP)(GLint size, GLenum type, GLsizei stride, const void *pointer)) OGLGETPROCADDRESS("glColorPointer");
+    if (!pfn_glColorPointer) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glCullFace, "");
+    pfn_glCullFace = (void (GLAPIENTRYP)(GLenum mode)) OGLGETPROCADDRESS("glCullFace");
+    if (!pfn_glCullFace) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glDeleteTextures, "");
+    pfn_glDeleteTextures = (void (GLAPIENTRYP)(GLsizei n, const GLuint *textures)) OGLGETPROCADDRESS("glDeleteTextures");
+    if (!pfn_glDeleteTextures) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glDepthFunc, "");
+    pfn_glDepthFunc = (void (GLAPIENTRYP)(GLenum func)) OGLGETPROCADDRESS("glDepthFunc");
+    if (!pfn_glDepthFunc) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glDepthMask, "");
+    pfn_glDepthMask = (void (GLAPIENTRYP)(GLboolean flag)) OGLGETPROCADDRESS("glDepthMask");
+    if (!pfn_glDepthMask) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glDepthRange, "");
+    pfn_glDepthRange = (void (GLAPIENTRYP)(GLclampd zNear, GLclampd zFar)) OGLGETPROCADDRESS("glDepthRange");
+    if (!pfn_glDepthRange) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glDisable, "");
+    pfn_glDisable = (void (GLAPIENTRYP)(GLenum cap)) OGLGETPROCADDRESS("glDisable");
+    if (!pfn_glDisable) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glDisableClientState, "");
+    pfn_glDisableClientState = (void (GLAPIENTRYP)(GLenum array)) OGLGETPROCADDRESS("glDisableClientState");
+    if (!pfn_glDisableClientState) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glDrawArrays, "");
+    pfn_glDrawArrays = (void (GLAPIENTRYP)(GLenum mode, GLint first, GLsizei count)) OGLGETPROCADDRESS("glDrawArrays");
+    if (!pfn_glDrawArrays) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glDrawElements, "");
+    pfn_glDrawElements = (void (GLAPIENTRYP)(GLenum mode, GLsizei count, GLenum type, const void *indices)) OGLGETPROCADDRESS("glDrawElements");
+    if (!pfn_glDrawElements) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glEnable, "");
+    pfn_glEnable = (void (GLAPIENTRYP)(GLenum cap)) OGLGETPROCADDRESS("glEnable");
+    if (!pfn_glEnable) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glEnableClientState, "");
+    pfn_glEnableClientState = (void (GLAPIENTRYP)(GLenum array)) OGLGETPROCADDRESS("glEnableClientState");
+    if (!pfn_glEnableClientState) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glEnd, "");
+    pfn_glEnd = (void (GLAPIENTRYP)(void)) OGLGETPROCADDRESS("glEnd");
+    if (!pfn_glEnd) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glFinish, "");
+    pfn_glFinish = (void (GLAPIENTRYP)(void)) OGLGETPROCADDRESS("glFinish");
+    if (!pfn_glFinish) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glFlush, "");
+    pfn_glFlush = (void (GLAPIENTRYP)(void)) OGLGETPROCADDRESS("glFlush");
+    if (!pfn_glFlush) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glFogf, "");
+    pfn_glFogf = (void (GLAPIENTRYP)(GLenum pname, GLfloat param)) OGLGETPROCADDRESS("glFogf");
+    if (!pfn_glFogf) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glFogfv, "");
+    pfn_glFogfv = (void (GLAPIENTRYP)(GLenum pname, const GLfloat *params)) OGLGETPROCADDRESS("glFogfv");
+    if (!pfn_glFogfv) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glFogi, "");
+    pfn_glFogi = (void (GLAPIENTRYP)(GLenum pname, GLint param)) OGLGETPROCADDRESS("glFogi");
+    if (!pfn_glFogi) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glFrontFace, "");
+    pfn_glFrontFace = (void (GLAPIENTRYP)(GLenum mode)) OGLGETPROCADDRESS("glFrontFacei");
+    if (!pfn_glFrontFace) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glGenTextures, "");
+    pfn_glGenTextures = (void (GLAPIENTRYP)(GLsizei n, GLuint *textures)) OGLGETPROCADDRESS("glGenTextures");
+    if (!pfn_glGenTextures) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glGetBooleanv, "");
+    pfn_glGetBooleanv = (void (GLAPIENTRYP)(GLenum pname, GLboolean *params)) OGLGETPROCADDRESS("glGetBooleanv");
+    if (!pfn_glGetBooleanv) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glGetError, "");
+    pfn_glGetError = (GLenum (GLAPIENTRYP)(void)) OGLGETPROCADDRESS("glGetError");
+    if (!pfn_glGetError) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glGetFloatv, "");
+    pfn_glGetFloatv = (void (GLAPIENTRYP)(GLenum pname, GLfloat *params)) OGLGETPROCADDRESS("glGetFloatv");
+    if (!pfn_glGetFloatv) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glGetIntegerv, "");
+    pfn_glGetIntegerv = (void (GLAPIENTRYP)(GLenum pname, GLint *params)) OGLGETPROCADDRESS("glGetIntegerv");
+    if (!pfn_glGetIntegerv) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glGetString, "");
+    pfn_glGetString = (const GLubyte * (GLAPIENTRYP)(GLenum name)) OGLGETPROCADDRESS("glGetString");
+    if (!pfn_glGetString) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glGetTexImage, "");
+    pfn_glGetTexImage = (void (GLAPIENTRYP)(GLenum target, GLint level, GLenum format, GLenum type, void *pixels)) OGLGETPROCADDRESS("glGetTexImage");
+    if (!pfn_glGetTexImage) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glLightModelfv, "");
+    pfn_glLightModelfv = (void (GLAPIENTRYP)(GLenum pname, const GLfloat *params)) OGLGETPROCADDRESS("glLightModelfv");
+    if (!pfn_glLightModelfv) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glLightf, "");
+    pfn_glLightf = (void (GLAPIENTRYP)(GLenum light, GLenum pname, GLfloat param)) OGLGETPROCADDRESS("glLightf");
+    if (!pfn_glLightf) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glLightfv, "");
+    pfn_glLightfv = (void (GLAPIENTRYP)(GLenum light, GLenum pname, const GLfloat *params)) OGLGETPROCADDRESS("glLightfv");
+    if (!pfn_glLightfv) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glLineWidth, "");
+    pfn_glLineWidth = (void (GLAPIENTRYP)(GLfloat width)) OGLGETPROCADDRESS("glLineWidth");
+    if (!pfn_glLineWidth) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glLoadIdentity, "");
+    pfn_glLoadIdentity = (void (GLAPIENTRYP)(void)) OGLGETPROCADDRESS("glLoadIdentity");
+    if (!pfn_glLoadIdentity) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glLoadMatrixf, "");
+    pfn_glLoadMatrixf = (void (GLAPIENTRYP)(const GLfloat *m)) OGLGETPROCADDRESS("glLoadMatrixf");
+    if (!pfn_glLoadMatrixf) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glMaterialfv, "");
+    pfn_glMaterialfv = (void (GLAPIENTRYP)(GLenum face, GLenum pname, const GLfloat *params)) OGLGETPROCADDRESS("glMaterialfv");
+    if (!pfn_glMaterialfv) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glMatrixMode, "");
+    pfn_glMatrixMode = (void (GLAPIENTRYP)(GLenum mode)) OGLGETPROCADDRESS("glMatrixMode");
+    if (!pfn_glMatrixMode) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glMultMatrixf, "");
+    pfn_glMultMatrixf = (void (GLAPIENTRYP)(const GLfloat *m)) OGLGETPROCADDRESS("glMultMatrixf");
+    if (!pfn_glMultMatrixf) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glNormalPointer, "");
+    pfn_glNormalPointer = (void (GLAPIENTRYP)(GLenum type, GLsizei stride, const void *pointer)) OGLGETPROCADDRESS("glNormalPointer");
+    if (!pfn_glNormalPointer) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glOrtho, "");
+    pfn_glOrtho = (void (GLAPIENTRYP)(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble nearVal, GLdouble farVal)) OGLGETPROCADDRESS("glOrtho");
+    if (!pfn_glOrtho) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glPixelStorei, "");
+    pfn_glPixelStorei = (void (GLAPIENTRYP)(GLenum pname, GLint param)) OGLGETPROCADDRESS("glPixelStorei");
+    if (!pfn_glPixelStorei) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glPointSize, "");
+    pfn_glPointSize = (void (GLAPIENTRYP)(GLfloat size)) OGLGETPROCADDRESS("glPointSize");
+    if (!pfn_glPointSize) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glPolygonMode, "");
+    pfn_glPolygonMode = (void (GLAPIENTRYP)(GLenum face, GLenum mode)) OGLGETPROCADDRESS("glPolygonMode");
+    if (!pfn_glPolygonMode) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glPolygonOffset, "");
+    pfn_glPolygonOffset = (void (GLAPIENTRYP)(GLfloat factor, GLfloat units)) OGLGETPROCADDRESS("glPolygonOffset");
+    if (!pfn_glPolygonOffset) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glPopAttrib, "");
+    pfn_glPopAttrib = (void (GLAPIENTRYP)(void)) OGLGETPROCADDRESS("glPopAttrib");
+    if (!pfn_glPopAttrib) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glPopMatrix, "");
+    pfn_glPopMatrix = (void (GLAPIENTRYP)(void)) OGLGETPROCADDRESS("glPopMatrix");
+    if (!pfn_glPopMatrix) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glPushAttrib, "");
+    pfn_glPushAttrib = (void (GLAPIENTRYP)(GLbitfield mask)) OGLGETPROCADDRESS("glPushAttrib");
+    if (!pfn_glPushAttrib) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glPushMatrix, "");
+    pfn_glPushMatrix = (void (GLAPIENTRYP)(void)) OGLGETPROCADDRESS("glPushMatrix");
+    if (!pfn_glPushMatrix) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glScissor, "");
+    pfn_glScissor = (void (GLAPIENTRYP)(GLint x, GLint y, GLsizei width, GLsizei height)) OGLGETPROCADDRESS("glScissor");
+    if (!pfn_glScissor) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glShadeModel, "");
+    pfn_glShadeModel = (void (GLAPIENTRYP)(GLenum mode)) OGLGETPROCADDRESS("glShadeModel");
+    if (!pfn_glShadeModel) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glStencilFunc, "");
+    pfn_glStencilFunc = (void (GLAPIENTRYP)(GLenum func, GLint ref, GLuint mask)) OGLGETPROCADDRESS("glStencilFunc");
+    if (!pfn_glStencilFunc) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glStencilMask, "");
+    pfn_glStencilMask = (void (GLAPIENTRYP)(GLuint mask)) OGLGETPROCADDRESS("glStencilMask");
+    if (!pfn_glStencilMask) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glStencilOp, "");
+    pfn_glStencilOp = (void (GLAPIENTRYP)(GLenum fail, GLenum zfail, GLenum zpass)) OGLGETPROCADDRESS("glStencilOp");
+    if (!pfn_glStencilOp) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glTexCoord2f, "");
+    pfn_glTexCoord2f = (void (GLAPIENTRYP)(GLfloat s, GLfloat t)) OGLGETPROCADDRESS("glTexCoord2f");
+    if (!pfn_glTexCoord2f) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glTexCoordPointer, "");
+    pfn_glTexCoordPointer = (void (GLAPIENTRYP)(GLint size, GLenum type, GLsizei stride, const void *pointer)) OGLGETPROCADDRESS("glTexCoordPointer");
+    if (!pfn_glTexCoordPointer) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glTexImage2D, "");
+    pfn_glTexImage2D = (void (GLAPIENTRYP)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels)) OGLGETPROCADDRESS("glTexImage2D");
+    if (!pfn_glTexImage2D) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glTexParameterf, "");
+    pfn_glTexParameterf = (void (GLAPIENTRYP)(GLenum target, GLenum pname, GLfloat param)) OGLGETPROCADDRESS("glTexParameterf");
+    if (!pfn_glTexParameterf) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glTexParameterfv, "");
+    pfn_glTexParameterfv = (void (GLAPIENTRYP)(GLenum target, GLenum pname, const GLfloat *params)) OGLGETPROCADDRESS("glTexParameterfv");
+    if (!pfn_glTexParameterfv) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glTexParameteri, "");
+    pfn_glTexParameteri = (void (GLAPIENTRYP)(GLenum target, GLenum pname, GLint param)) OGLGETPROCADDRESS("glTexParameteri");
+    if (!pfn_glTexParameteri) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glTexSubImage2D, "");
+    pfn_glTexSubImage2D = (void (GLAPIENTRYP)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels)) OGLGETPROCADDRESS("glTexSubImage2D");
+    if (!pfn_glTexSubImage2D) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glVertex2i, "");
+    pfn_glVertex2i = (void (GLAPIENTRYP)(GLint x, GLint y)) OGLGETPROCADDRESS("glVertex2i");
+    if (!pfn_glVertex2i) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glVertexPointer, "");
+    pfn_glVertexPointer = (void (GLAPIENTRYP)(GLint size, GLenum type, GLsizei stride, const void *pointer)) OGLGETPROCADDRESS("glVertexPointer");
+    if (!pfn_glVertexPointer) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glViewport, "");
+    pfn_glViewport = (void (GLAPIENTRYP)(GLint x, GLint y, GLsizei width, GLsizei height)) OGLGETPROCADDRESS("glViewport");
+    if (!pfn_glViewport) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
 
 #ifdef RT_OS_LINUX
     XInitThreads();
@@ -420,9 +620,14 @@ PFNRT glLdrGetProcAddress(const char *pszSymbol)
 
 int glLdrGetExtFunctions(PPDMDEVINS pDevIns)
 {
-    PFNRT pfnRet;
-    GLGETPROC_(glBlendColor, "");
-    GLGETPROC_(glBlendEquation, "");
-    GLGETPROC_(glClientActiveTexture, "");
+    // GLGETPROC_(glBlendColor, "");
+    pfn_glBlendColor = (void (GLAPIENTRYP)(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)) OGLGETPROCADDRESS("glBlendColor");
+    if (!pfn_glBlendColor) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glBlendEquation, "");
+    pfn_glBlendEquation = (void (GLAPIENTRYP)(GLenum mode)) OGLGETPROCADDRESS("glBlendEquation");
+    if (!pfn_glBlendEquation) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
+    // GLGETPROC_(glClientActiveTexture, "");
+    pfn_glClientActiveTexture = (void (GLAPIENTRYP)(GLenum texture)) OGLGETPROCADDRESS("glClientActiveTexture");
+    if (!pfn_glClientActiveTexture) { PDMDevHlpVMSetError(pDevIns, VERR_VGA_GL_SYMBOL_NOT_FOUND, RT_SRC_POS, "Missing OpenGL symbol");}
     return VINF_SUCCESS;
 }
diff --git a/src/VBox/Devices/Makefile.kmk b/src/VBox/Devices/Makefile.kmk
index 3e22f141..2635ac50 100644
--- a/src/VBox/Devices/Makefile.kmk
+++ b/src/VBox/Devices/Makefile.kmk
@@ -35,7 +35,8 @@ endif
 
 # Include sub-makefiles.
 if1of ($(KBUILD_TARGET_ARCH), $(VBOX_SUPPORTED_HOST_ARCHS))
- include $(PATH_SUB_CURRENT)/testcase/Makefile.kmk
+ # tstDeviceStructSize is not compatible with asan
+ # include $(PATH_SUB_CURRENT)/testcase/Makefile.kmk
  include $(PATH_SUB_CURRENT)/Audio/testcase/Makefile.kmk
  include $(PATH_SUB_CURRENT)/Input/testcase/Makefile.kmk
  ifdef VBOX_WITH_TESTCASES
@@ -158,6 +159,11 @@ if !defined(VBOX_ONLY_EXTPACKS) && "$(intersects $(KBUILD_TARGET_ARCH),$(VBOX_SU
  else
   VBoxDD_TEMPLATE         = VBoxR3DllWarnNoPic
  endif
+ ifdef VBOXDD_SANITIZER
+  VBoxDD_CFLAGS         += -fsanitize=address,undefined -fno-sanitize=alignment -fsanitize-recover=address
+  VBoxDD_CXXFLAGS       += -fsanitize=address,undefined -fno-sanitize=alignment -fsanitize-recover=address
+  VboxDD_LDFLAGS        += -fsanitize=address,undefined -fno-sanitize=alignment -fsanitize-recover=address
+ endif
  VBoxDD_SDKS.win         = ReorderCompilerIncs $(VBOX_WINPSDK) $(VBOX_WINDDK) VBoxNtDll
  Storage/DrvHostDVD.cpp_SDKS.win = ReorderCompilerIncs $(VBOX_WINDDK)
  VBoxDD_INCS             = \
diff --git a/src/VBox/Devices/Storage/DevFdc.cpp b/src/VBox/Devices/Storage/DevFdc.cpp
index bed747af..ab2bd2e3 100644
--- a/src/VBox/Devices/Storage/DevFdc.cpp
+++ b/src/VBox/Devices/Storage/DevFdc.cpp
@@ -89,7 +89,7 @@
 # define FLOPPY_DPRINTF(...) do { } while (0)
 #endif
 
-#define FLOPPY_ERROR RTLogPrintf
+#define FLOPPY_ERROR FLOPPY_DPRINTF
 
 typedef struct fdctrl_t fdctrl_t;
 
diff --git a/src/VBox/Devices/USB/DevOHCI.cpp b/src/VBox/Devices/USB/DevOHCI.cpp
index cd139e98..3bda5d5d 100644
--- a/src/VBox/Devices/USB/DevOHCI.cpp
+++ b/src/VBox/Devices/USB/DevOHCI.cpp
@@ -777,7 +777,6 @@ typedef OHCIPHYSREADSTATS *POHCIPHYSREADSTATS;
 typedef OHCIPHYSREADSTATS const *PCOHCIPHYSREADSTATS;
 #endif /* VBOX_WITH_OHCI_PHYS_READ_STATS */
 
-
 /*********************************************************************************************************************************
 *   Global Variables                                                                                                             *
 *********************************************************************************************************************************/
@@ -3654,12 +3653,17 @@ static void ohciR3ServiceIsochronousEndpoint(PPDMDEVINS pDevIns, POHCI pThis, PO
     uint32_t ITdAddrPrev = 0;
     uint32_t u32NextFrame = UINT32_MAX;
     const uint16_t u16CurFrame = pThis->HcFmNumber;
+    int counter = 0;
     for (;;)
     {
         /* check for end-of-chain. */
         if (    ITdAddr == (pEd->TailP & ED_PTR_MASK)
             ||  !ITdAddr)
             break;
+        counter++;
+        if (counter > 10) {
+            break;
+        }
 
         /*
          * If isochronous endpoints are around, don't slow down the timer. Getting the timing right
diff --git a/src/VBox/Devices/build/VBoxDD.cpp b/src/VBox/Devices/build/VBoxDD.cpp
index 1e88822d..31e88e0c 100644
--- a/src/VBox/Devices/build/VBoxDD.cpp
+++ b/src/VBox/Devices/build/VBoxDD.cpp
@@ -39,6 +39,9 @@
 #include <iprt/assert.h>
 
 #include "VBoxDD.h"
+#ifdef CLANG_COV_DUMP
+#include "clangcovdump.h"
+#endif
 
 
 /*********************************************************************************************************************************
@@ -59,6 +62,12 @@ const void *g_apvVBoxDDDependencies[] =
  */
 extern "C" DECLEXPORT(int) VBoxDevicesRegister(PPDMDEVREGCB pCallbacks, uint32_t u32Version)
 {
+    // HACK
+    // we want to dump the coverage in VBoxDD.so
+#ifdef CLANG_COV_DUMP
+    llvm_profile_initialize_file(false);
+#endif
+
     LogFlow(("VBoxDevicesRegister: u32Version=%#x\n", u32Version));
     AssertReleaseMsg(u32Version == VBOX_VERSION, ("u32Version=%#x VBOX_VERSION=%#x\n", u32Version, VBOX_VERSION));
     int rc;
diff --git a/src/VBox/ExtPacks/VBoxDTrace/include/VBoxDTraceLibCWrappers.h b/src/VBox/ExtPacks/VBoxDTrace/include/VBoxDTraceLibCWrappers.h
index b2345519..5aae7e95 100644
--- a/src/VBox/ExtPacks/VBoxDTrace/include/VBoxDTraceLibCWrappers.h
+++ b/src/VBox/ExtPacks/VBoxDTrace/include/VBoxDTraceLibCWrappers.h
@@ -35,7 +35,7 @@
 # ifdef RT_OS_DARWIN
 #  include <sys/syslimits.h> /* PATH_MAX */
 # elif !defined(RT_OS_SOLARIS) && !defined(RT_OS_FREEBSD)
-#  include <syslimits.h>    /* PATH_MAX */
+#  include <limits.h>    /* PATH_MAX */
 # endif
 # include <libgen.h>        /* basename */
 # include <unistd.h>
diff --git a/src/VBox/Frontends/VBoxManage/Makefile.kmk b/src/VBox/Frontends/VBoxManage/Makefile.kmk
index 2a63da42..6b2f6290 100644
--- a/src/VBox/Frontends/VBoxManage/Makefile.kmk
+++ b/src/VBox/Frontends/VBoxManage/Makefile.kmk
@@ -78,8 +78,7 @@ ifndef VBOX_ONLY_DOCS
  	../Common
  VBoxManage_INTERMEDIATES = \
  	$(VBoxManage_0_OUTDIR)/VBoxManageBuiltInHelp.h
- VBoxManage_SOURCES    = \
- 	VBoxManage.cpp \
+ VBoxManage_COMMON_SOURCES    = \
  	VBoxManageUtils.cpp \
  	VBoxInternalManage.cpp \
  	VBoxManageAppliance.cpp \
@@ -110,6 +109,9 @@ ifndef VBOX_ONLY_DOCS
  	VBoxManageCloud.cpp \
  	VBoxManageCloudMachine.cpp \
  	../Common/PasswordInput.cpp
+ VBoxManage_SOURCES    = \
+ 	VBoxManage.cpp \
+	$(VBoxManage_COMMON_SOURCES)
  VBoxManage_SOURCES.win = \
  	VBoxManage.rc
  VBoxManage_LIBS      += $(LIB_DDU)
@@ -410,4 +412,26 @@ ifdef VBOX_WITH_VBOXMANAGE_NLS
 
 endif
 
+ifndef VBOX_ONLY_DOCS
+ifdef VBOX_WITH_VIDEZZO
+ PROGRAMS += VBoxViDeZZo
+ VBoxViDeZZo_TEMPLATE   = VBoxMainClientExe
+ VBoxViDeZZo_DEFS      += $(VBOX_COMMON_VBOXMANAGE_DEFS) $(VMM_COMMON_DEFS)
+ VBoxViDeZZo_INCS       = \
+    $(VBoxManage_INCS) \
+	/usr/include/glib-2.0 \
+	/usr/lib/x86_64-linux-gnu/glib-2.0/include \
+	../../VMM/include
+ VBoxViDeZZo_SOURCES    = \
+	VBoxViDeZZo.cpp \
+	$(VBoxManage_COMMON_SOURCES)
+ VBoxViDeZZo_LDFLAGS += \
+	-L$(PATH_SUB_CURRENT)/src/VBox/Frontends/VBoxManage \
+	$(VBOX_FUZZ_LDFLAGS)
+ VBoxViDeZZo_LIBS += \
+    videzzo vncclient gmodule-2.0 glib-2.0 ssl crypto $(LIB_VMM) \
+    $(LIB_DDU)
+endif
+endif # VBOX_ONLY_DOCS
+
 include $(FILE_KBUILD_SUB_FOOTER)
diff --git a/src/VBox/HostServices/SharedFolders/Makefile.kmk b/src/VBox/HostServices/SharedFolders/Makefile.kmk
index fc0ff6c5..7a9bf199 100644
--- a/src/VBox/HostServices/SharedFolders/Makefile.kmk
+++ b/src/VBox/HostServices/SharedFolders/Makefile.kmk
@@ -29,7 +29,8 @@ SUB_DEPTH = ../../../..
 include $(KBUILD_PATH)/subheader.kmk
 
 # Include sub-makefile(s).
-include $(PATH_SUB_CURRENT)/testcase/Makefile.kmk
+# tstShflSizes is not compatible with asan
+# include $(PATH_SUB_CURRENT)/testcase/Makefile.kmk
 
 #
 # The shared folder service DLL.
diff --git a/src/VBox/Runtime/Makefile.kmk b/src/VBox/Runtime/Makefile.kmk
index 09b01623..26fc5204 100644
--- a/src/VBox/Runtime/Makefile.kmk
+++ b/src/VBox/Runtime/Makefile.kmk
@@ -4675,7 +4675,7 @@ if1of ($(LIBRARIES), RuntimeR3 RuntimeR0 RuntimeR0Drv RuntimeRC)
  		$$(RuntimeR0_1_TARGET) \
  		$$(RuntimeR0Drv_1_TARGET) \
  		$$(RuntimeRC_1_TARGET)
- if1of ($(KBUILD_TARGET), win os2)
+ if1of ($(KBUILD_TARGET), win os2 linux)
 	$(call MSG_L1,IPRT: skipped mangling test.)
  else
   # Generate a SED script from mangling.h that checks for known symbols.
@@ -4757,6 +4757,12 @@ if1of ($(LIBRARIES), RuntimeR3 RuntimeR0 RuntimeR0Drv RuntimeRC)
 			\
 			-e '/^VBoxHost_/d'\
 			-e '/^VBoxGuest_/d'\
+			\
+			-e '/^_ZT[IS]F/d' \
+			\
+			-e '/__covrec_/d' \
+			-e '/RTLogDefaultInit/d' \
+			-e '/rtstrFormatRt/d' \
 		| $(SED) -nf "$@"
   endif
 	$(call MSG_L1,IPRT: Testing mangling using nm...)
diff --git a/src/VBox/VMM/Makefile.kmk b/src/VBox/VMM/Makefile.kmk
index 1d87ac3f..50145a86 100644
--- a/src/VBox/VMM/Makefile.kmk
+++ b/src/VBox/VMM/Makefile.kmk
@@ -36,7 +36,8 @@ endif
 # Include sub-makefiles.
 ifndef VBOX_ONLY_EXTPACKS
  include $(PATH_SUB_CURRENT)/tools/Makefile.kmk
- include $(PATH_SUB_CURRENT)/testcase/Makefile.kmk
+ # tstAsmStructs is not compatible with asan 
+ # include $(PATH_SUB_CURRENT)/testcase/Makefile.kmk
 endif
 
 
diff --git a/src/VBox/VMM/VMMAll/PGMAllPhys.cpp b/src/VBox/VMM/VMMAll/PGMAllPhys.cpp
index 9aa351d9..53bbcf09 100644
--- a/src/VBox/VMM/VMMAll/PGMAllPhys.cpp
+++ b/src/VBox/VMM/VMMAll/PGMAllPhys.cpp
@@ -1860,13 +1860,13 @@ int pgmPhysGCPhys2CCPtrInternal(PVMCC pVM, PPGMPAGE pPage, RTGCPHYS GCPhys, void
     /*
      * Make sure the page is writable.
      */
-    if (RT_UNLIKELY(PGM_PAGE_GET_STATE(pPage) != PGM_PAGE_STATE_ALLOCATED))
-    {
-        rc = pgmPhysPageMakeWritable(pVM, pPage, GCPhys);
-        if (RT_FAILURE(rc))
-            return rc;
-        AssertMsg(rc == VINF_SUCCESS || rc == VINF_PGM_SYNC_CR3 /* not returned */, ("%Rrc\n", rc));
-    }
+    // if (RT_UNLIKELY(PGM_PAGE_GET_STATE(pPage) != PGM_PAGE_STATE_ALLOCATED))
+    // {
+        // rc = pgmPhysPageMakeWritable(pVM, pPage, GCPhys);
+        // if (RT_FAILURE(rc))
+            // return rc;
+        // AssertMsg(rc == VINF_SUCCESS || rc == VINF_PGM_SYNC_CR3 /* not returned */, ("%Rrc\n", rc));
+    // }
     Assert(PGM_PAGE_GET_HCPHYS(pPage) != 0);
 
     /*
diff --git a/src/VBox/VMM/VMMAll/PGMAllPool.cpp b/src/VBox/VMM/VMMAll/PGMAllPool.cpp
index aec01623..5e6ce4ce 100644
--- a/src/VBox/VMM/VMMAll/PGMAllPool.cpp
+++ b/src/VBox/VMM/VMMAll/PGMAllPool.cpp
@@ -5493,7 +5493,7 @@ int pgmPoolAlloc(PVMCC pVM, RTGCPHYS GCPhys, PGMPOOLKIND enmKind, PGMPOOLACCESS
     {
         STAM_PROFILE_START(&pPool->StatZeroPage, z);
         void *pv = PGMPOOL_PAGE_2_PTR(pVM, pPage);
-        ASMMemZeroPage(pv);
+        // ASMMemZeroPage(pv);
         STAM_PROFILE_STOP(&pPool->StatZeroPage, z);
     }
 
diff --git a/src/VBox/VMM/VMMR3/PGMPhys.cpp b/src/VBox/VMM/VMMR3/PGMPhys.cpp
index fb9fd668..747f5843 100644
--- a/src/VBox/VMM/VMMR3/PGMPhys.cpp
+++ b/src/VBox/VMM/VMMR3/PGMPhys.cpp
@@ -5912,23 +5912,23 @@ VMMR3DECL(int) PGMR3PhysAllocateHandyPages(PVM pVM)
             && rc != VERR_LOCK_FAILED)
             for (uint32_t i = 0; i < RT_ELEMENTS(pVM->pgm.s.aHandyPages); i++)
             {
-                LogRel(("PGM: aHandyPages[#%#04x] = {.HCPhysGCPhys=%RHp, .idPage=%#08x, .idSharedPage=%#08x}\n",
-                        i, pVM->pgm.s.aHandyPages[i].HCPhysGCPhys, pVM->pgm.s.aHandyPages[i].idPage,
-                        pVM->pgm.s.aHandyPages[i].idSharedPage));
-                uint32_t const idPage = pVM->pgm.s.aHandyPages[i].idPage;
-                if (idPage != NIL_GMM_PAGEID)
-                {
-                    for (PPGMRAMRANGE pRam = pVM->pgm.s.pRamRangesXR3;
-                         pRam;
-                         pRam = pRam->pNextR3)
-                    {
-                        uint32_t const cPages = pRam->cb >> GUEST_PAGE_SHIFT;
-                        for (uint32_t iPage = 0; iPage < cPages; iPage++)
-                            if (PGM_PAGE_GET_PAGEID(&pRam->aPages[iPage]) == idPage)
-                                LogRel(("PGM: Used by %RGp %R[pgmpage] (%s)\n",
-                                        pRam->GCPhys + ((RTGCPHYS)iPage << GUEST_PAGE_SHIFT), &pRam->aPages[iPage], pRam->pszDesc));
-                    }
-                }
+                // LogRel(("PGM: aHandyPages[#%#04x] = {.HCPhysGCPhys=%RHp, .idPage=%#08x, .idSharedPage=%#08x}\n",
+                        // i, pVM->pgm.s.aHandyPages[i].HCPhysGCPhys, pVM->pgm.s.aHandyPages[i].idPage,
+                        // pVM->pgm.s.aHandyPages[i].idSharedPage));
+                // uint32_t const idPage = pVM->pgm.s.aHandyPages[i].idPage;
+                // if (idPage != NIL_GMM_PAGEID)
+                // {
+                    // for (PPGMRAMRANGE pRam = pVM->pgm.s.pRamRangesXR3;
+                         // pRam;
+                         // pRam = pRam->pNextR3)
+                    // {
+                        // uint32_t const cPages = pRam->cb >> GUEST_PAGE_SHIFT;
+                        // for (uint32_t iPage = 0; iPage < cPages; iPage++)
+                            // if (PGM_PAGE_GET_PAGEID(&pRam->aPages[iPage]) == idPage)
+                                // LogRel(("PGM: Used by %RGp %R[pgmpage] (%s)\n",
+                                        // pRam->GCPhys + ((RTGCPHYS)iPage << GUEST_PAGE_SHIFT), &pRam->aPages[iPage], pRam->pszDesc));
+                    // }
+                // }
             }
 
         if (rc == VERR_NO_MEMORY)
diff --git a/src/libs/xpcom18a4/nsprpub/pr/src/md/unix/os_Linux_x86_64.s b/src/libs/xpcom18a4/nsprpub/pr/src/md/unix/os_Linux_x86_64.s
index 567ae12d..0dec1b90 100644
--- a/src/libs/xpcom18a4/nsprpub/pr/src/md/unix/os_Linux_x86_64.s
+++ b/src/libs/xpcom18a4/nsprpub/pr/src/md/unix/os_Linux_x86_64.s
@@ -1,42 +1,42 @@
-/ -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
-/ 
-/ The contents of this file are subject to the Mozilla Public
-/ License Version 1.1 (the "License"); you may not use this file
-/ except in compliance with the License. You may obtain a copy of
-/ the License at http://www.mozilla.org/MPL/
-/ 
-/ Software distributed under the License is distributed on an "AS
-/ IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
-/ implied. See the License for the specific language governing
-/ rights and limitations under the License.
-/ 
-/ The Original Code is the Netscape Portable Runtime (NSPR).
-/ 
-/ The Initial Developer of the Original Code is Netscape
-/ Communications Corporation.  Portions created by Netscape are 
-/ Copyright (C) 2004 Netscape Communications Corporation.  All
-/ Rights Reserved.
-/ 
-/ Contributor(s):
-/ 
-/ Alternatively, the contents of this file may be used under the
-/ terms of the GNU General Public License Version 2 or later (the
-/ "GPL"), in which case the provisions of the GPL are applicable 
-/ instead of those above.  If you wish to allow use of your 
-/ version of this file only under the terms of the GPL and not to
-/ allow others to use your version of this file under the MPL,
-/ indicate your decision by deleting the provisions above and
-/ replace them with the notice and other provisions required by
-/ the GPL.  If you do not delete the provisions above, a recipient
-/ may use your version of this file under either the MPL or the
-/ GPL.
-/ 
-
-/ PRInt32 _PR_x86_64_AtomicIncrement(PRInt32 *val)
-/
-/ Atomically increment the integer pointed to by 'val' and return
-/ the result of the increment.
-/
+// -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+// 
+// The contents of this file are subject to the Mozilla Public
+// License Version 1.1 (the "License"); you may not use this file
+// except in compliance with the License. You may obtain a copy of
+// the License at http://www.mozilla.org/MPL/
+// 
+// Software distributed under the License is distributed on an "AS
+// IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+// implied. See the License for the specific language governing
+// rights and limitations under the License.
+// 
+// The Original Code is the Netscape Portable Runtime (NSPR).
+// 
+// The Initial Developer of the Original Code is Netscape
+// Communications Corporation.  Portions created by Netscape are 
+// Copyright (C) 2004 Netscape Communications Corporation.  All
+// Rights Reserved.
+// 
+// Contributor(s):
+// 
+// Alternatively, the contents of this file may be used under the
+// terms of the GNU General Public License Version 2 or later (the
+// "GPL"), in which case the provisions of the GPL are applicable 
+// instead of those above.  If you wish to allow use of your 
+// version of this file only under the terms of the GPL and not to
+// allow others to use your version of this file under the MPL,
+// indicate your decision by deleting the provisions above and
+// replace them with the notice and other provisions required by
+// the GPL.  If you do not delete the provisions above, a recipient
+// may use your version of this file under either the MPL or the
+// GPL.
+// 
+//
+// PRInt32 _PR_x86_64_AtomicIncrement(PRInt32 *val)
+//
+// Atomically increment the integer pointed to by 'val' and return
+// the result of the increment.
+//
     .text
     .globl _PR_x86_64_AtomicIncrement
     .align 4
@@ -47,11 +47,11 @@ _PR_x86_64_AtomicIncrement:
     incl %eax
     ret
 
-/ PRInt32 _PR_x86_64_AtomicDecrement(PRInt32 *val)
-/
-/ Atomically decrement the integer pointed to by 'val' and return
-/ the result of the decrement.
-/
+// PRInt32 _PR_x86_64_AtomicDecrement(PRInt32 *val)
+//
+// Atomically decrement the integer pointed to by 'val' and return
+// the result of the decrement.
+//
     .text
     .globl _PR_x86_64_AtomicDecrement
     .align 4
@@ -62,11 +62,11 @@ _PR_x86_64_AtomicDecrement:
     decl %eax
     ret
 
-/ PRInt32 _PR_x86_64_AtomicSet(PRInt32 *val, PRInt32 newval)
-/
-/ Atomically set the integer pointed to by 'val' to the new
-/ value 'newval' and return the old value.
-/
+// PRInt32 _PR_x86_64_AtomicSet(PRInt32 *val, PRInt32 newval)
+//
+// Atomically set the integer pointed to by 'val' to the new
+// value 'newval' and return the old value.
+//
     .text
     .globl _PR_x86_64_AtomicSet
     .align 4
@@ -76,11 +76,11 @@ _PR_x86_64_AtomicSet:
     xchgl %eax, (%rdi)
     ret
 
-/ PRInt32 _PR_x86_64_AtomicAdd(PRInt32 *ptr, PRInt32 val)
-/
-/ Atomically add 'val' to the integer pointed to by 'ptr'
-/ and return the result of the addition.
-/
+// PRInt32 _PR_x86_64_AtomicAdd(PRInt32 *ptr, PRInt32 val)
+//
+// Atomically add 'val' to the integer pointed to by 'ptr'
+// and return the result of the addition.
+//
     .text
     .globl _PR_x86_64_AtomicAdd
     .align 4
@@ -91,5 +91,5 @@ _PR_x86_64_AtomicAdd:
     addl %esi, %eax
     ret
 
-/ Magic indicating no need for an executable stack
+// Magic indicating no need for an executable stack
 .section .note.GNU-stack, "", @progbits ; .previous
